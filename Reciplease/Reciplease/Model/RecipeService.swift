//
//  RecipeService.swift
//  Reciplease
//
//  Created by Ernesto Elias Aquino Cifuentes on 12/06/2022.
//

import Foundation
import CoreData

final public class RecipeService {
// MARK: - Variables
    weak var viewDelegate: SearchDelegate?
    weak var searchResultViewDelegate: SearchResultDelegate?

    var listIngredients: [String] = ["chicken", "curry", "tomatoes"]
    var nextRecipes: String?
    var listRecipes: [LocalRecipe] = []
    let networkManager = NetworkManager<RecipeResponse>()

    init(recipes: [LocalRecipe], nextRexipes: String?) {
        self.listRecipes = recipes
        self.nextRecipes = nextRexipes
    }

// MARK: - Funtions

    /**
     This function adds the ingredients entered by the user to the list of ingredients.
     
     - parameter ingredients: String with the ingredient. Multiple ingredients can be added at the same time as long as they are separated by a comma.
     */
    public func addIngredients(_ ingredients: String?) {
        guard let ingredients = ingredients else {return}
        let ingredientWithoutSpaces =  trimmingAllSpaces(ingredients)
        if ingredientWithoutSpaces.isEmpty {
            return
        }
        if ingredientWithoutSpaces.contains(",") {
            let tabIngredients = splitIngredients(ingredientWithoutSpaces)
            for ingredient in tabIngredients {
                refreshListIngredientWith("- " + ingredient.capitalized + "\n")
                listIngredients.append(ingredient)
            }
            clearIngredientTextField()
        } else {
            refreshListIngredientWith("- " + ingredientWithoutSpaces.capitalized + "\n")
            listIngredients.append(ingredientWithoutSpaces)
            clearIngredientTextField()
        }
    }

    /**
     This function makes the Request to the Edeman api with the ingredients stored in the " listIngredients " property.
     */
    public func getRecipes() {
        guard !listIngredients.isEmpty else {
            warningMessage("Please enter at least one ingredient.")
            return
        }
        let request = createRequest()
        showActivityIndicator(true)
        networkManager.getInformation(request: request) { recipeResponse, error in
            self.showActivityIndicator(false)
            guard  error == nil,
                   let recipeResponse = recipeResponse else {
                return
            }
            if let nextURL = recipeResponse.links?.next?.href {
                self.nextRecipes = nextURL
            }
            self.addRecipes(recipeResponse)
            self.goToSearchResultViewController(recipes: self.listRecipes, nextURL: self.nextRecipes)
        }
    }

    /**
     This function adds the recipes received in the request response to the listRepices variable.
     
     - parameter recipes: Response returned by the request.
     */
    private func addRecipes(_ recipes: RecipeResponse) {

        guard let hits = recipes.hits else { return }
        for hit in hits {
            guard let recipe = hit.recipe else { return }
            let image = recipe.imageData
            let portions = String(Int(recipe.yield ?? 0)) + " servings\t"
            let title = recipe.label ?? ""
            let time = String(Int(recipe.totalTime ?? 0)) + " minutes\t"
            let ingredients = recipe.ingredientLines ?? []
            let source = recipe.url
            let url = recipe.image

            let newRecipe = LocalRecipe(image: image, name: title, portions: portions, preparationTime: time, ingredientsDetail: ingredients, urlImage: url, sourceUrl: source)
            listRecipes.append(newRecipe)
            }
    }

    /**
     This function trims a string using the comma " , " as a reference.
     
     - parameter ingredients: The string to be trimmed
     
     - returns: Returns a string table with the trimmed elements.
     */
    private func splitIngredients(_ ingredients: String) -> [String] {
        let ingredientsWithoutSpaces = trimmingAllSpaces(ingredients)
        return ingredientsWithoutSpaces.split(separator: ",").map{"\($0)"}
    }

    /**
     This function removes whitespace from a string.
     
     - parameter string: String with spaces to be removed.
     
     - returns: String without spaces or line breaks.
     */
    private func trimmingAllSpaces(_ string: String) -> String {
        return string.components(separatedBy: .whitespacesAndNewlines).joined()
    }

    /**
     This function recovers the url generated by the createURL() function, and builds an optional instance of URL Request.
     
     - returns:  Returns an optional instance of URL Request with GET method.
     */
    private func createRequest() -> URLRequest? {
           guard let url = createURL() else {
               return nil
           }
           let request = URLRequest(url: url)
           return request
       }

    /**
     This function constructs a url using the API key.
     
     - returns: Returns an optional url.
     */
    private func createURL() -> URL? {
        let endPoint = "https://api.edamam.com/api/recipes/v2?"
        let type = "public"
        let ingredients = listIngredients.joined(separator: ",")
        let app_id = "f3afe7be"
        let app_key = "cfa430402075604d56fc1e8c94096b51"

        guard let escapedIngredients = ingredients.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed),
              let url = URL(string: "\(endPoint)type=\(type)&q=\(escapedIngredients)&app_id=\(app_id)&app_key=\(app_key)")
        else {
            return nil
        }
        return url
    }

    /**
     This function makes a second request to obtain more results if necessary.
     */
    public func getNextRecipes() {
        guard nextRecipes != nil else {
            warningMessage("Sorry, but there are no more results.")
            return
        }
        guard let nextRecipes = nextRecipes,
              let url = URL(string: nextRecipes) else {return}
        let request = URLRequest(url: url)
        networkManager.getInformation(request: request) { recipeResponse, error in
            guard  error == nil,
                   let recipeResponse = recipeResponse else {
                return
            }
            if let nextURL = recipeResponse.links?.next?.href {
                self.nextRecipes = nextURL
            }
            self.addRecipes(recipeResponse)
        }
    }

    /**
     This function retrieves the image of the recipe.
    
     - parameter index: Index of the recipe inside listRecipe
     */
    public func getImage(index: Int) {
        guard index < listRecipes.count else {return}
        if listRecipes[index].image == nil {
            networkManager.getImage(url: listRecipes[index].urlImage) { img in
                guard let img = img else { return }
                self.listRecipes[index].image = img
                self.reloadTableView()
            }
        }
    }

    /**
     This function saves the recipe using Core Data so that it can be consulted offline.
     
     - parameter recipeToSave: recipe to be saved.
     */
    func saveRecipe(_ recipeToSave: LocalRecipe?) {
        guard let recipeToSave = recipeToSave else { return }
        let recipe = FavoriteRecipe(context: CoreDataStack.shared.viewContext)
        recipe.image = recipeToSave.image
        recipe.name = recipeToSave.name
        recipe.portions = recipeToSave.portions
        recipe.preparationTime = recipeToSave.preparationTime
        recipe.ingredientsDetail = recipeToSave.ingredientsDetail.joined(separator: "\n")
        recipe.urlImage = recipeToSave.urlImage
        recipe.sourceUrl = recipeToSave.sourceUrl

        do {
            try CoreDataStack.shared.viewContext.save()
        } catch  {
            warningMessage("Sorry, we have encountered an error saving the recipe.")
        }
    }
}
